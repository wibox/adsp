import os
import itertools
import json
# import warnings
# warnings.filterwarnings("ignore", message="Warning 1: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.")
from typing import *

from tqdm import tqdm

import rasterio as rio
# rio.logging.getLogger().setLevel(rio.logging.FATAL)
import numpy as np

from Utils.errors import *

class DatasetFormatter():
    """
    This class performs tiling over appropriately formatted images according to input dimensions.
    """
    def __init__(self, master_folder_path=None, log_file_path=None, log_filename=None, master_dict_path=None, master_dict_filename=None, valid_list=None, tile_height=512, tile_width=512, thr_pixels = 112, use_pre=False, dataset=None, verbose=0):
        self.master_folder_path=master_folder_path
        self.log_file_path=log_file_path
        self.log_filename=log_filename
        self.master_dict_path=master_dict_path
        self.master_dict_filename=master_dict_filename,
        self.valid_list=valid_list
        self.tile_height=tile_height
        self.tile_width=tile_width
        self.thr_pixels = thr_pixels
        self.use_pre=use_pre
        self.dataset=dataset
        self.verbose=verbose

        self.master_dict_info = {"processing_info": []}

        self.logging_info = dict()

        if self.use_pre:
            self.input_paths_subitems = ["pre", "post", "mask"]
        else:
            self.input_paths_subitems = ["post", "mask"]

    def build_input_paths(self) -> Tuple[Union[Dict[str, str], None], Union[List[str], None]]:
        """
        This function uses the log file generated by an instance of DatasetScanner to build the input paths of every activation.
        """
        input_paths = dict()
        activations = list()
        try:
            with open(f"{self.log_file_path}/{self.log_filename}", "r") as act_paths_file:
                next(act_paths_file) # skip header
                for act_path in act_paths_file:
                    act_id = act_path.split(",")[0]
                    post = act_path.split(",")[2]
                    mask = act_path.split(",")[3].rstrip() # removing \n characters
                    if self.use_pre:
                        pre = act_path.split(",")[1].rstrip()
                        input_paths[act_id] = {
                            "pre" : pre,
                            "post" : post,
                            "mask" : mask
                        }
                    else:
                        input_paths[act_id] = {
                                "post" : post,
                                "mask" : mask
                            }
                    activations.append(act_id)
                    if (input_paths[act_id]["pre"] is None) or (input_paths[act_id]["post"] is None) or (input_paths[act_id]["mask"] is None):
                        raise NoneTypeEncountered(correct_type=str, message=f"Either one pre/post/mask for {act_id} is NoneType.")
            if len(activations) == 0:
                raise EmptyListEncountered(list_name="activations", expected_content="activations' id")
        except OSError as ose:
            print(ose)
        except EmptyListEncountered as ele:
            print(ele)
        finally:
            if self.verbose==1:
                print("Finished building input paths list. Proceeding.")
            return input_paths, activations
    
    def log_dict_info_to_file(self) -> bool:
        """
        This function is called at the end of the tiling process to log the json object containing informations relative to
        the absolute path of each tiled mask/pre/post for every activation contained in master_folder_log_<dataset>.csv
        """
        completed = False
        try:
            with open(f"{os.path.join(self.master_dict_path, self.master_dict_filename[0])}", "w") as mdfp:
                json.dump(self.master_dict_info, mdfp, indent=4)
                completed=True
        except OSError as ose:
            print(ose)
        finally:
            return completed

    def offset_tiles(self, img : Union[np.ndarray, None] = None, tile_dim : Tuple[int, int] = (512, 512)) -> Tuple[Union[List[float], Any], Union[List[float], Any]]:
        """
        This function performs the tiling of an input image according to specific criteria.
        If image shape is not (<num_channels>, <height>, <width>) then expand one dimension.
        If image.height % <tile_size> |= 0 or image.width % <tile_size> != 0 perform overlapping with threshold.
        """
        try:
            if img is None:
                raise NotAnImage(path=img)
            if len(img.shape) == 2:
                axis = 0
                img = np.expand_dims(img, axis = axis)
                # da aggiungere se vogliamo i channel alla fine.
                #img = np.moveaxis(img, 0, -1)
            # cambiare questo se non è channel first
            _, heigth, width = img.shape
            tile_h, tile_w = tile_dim
            # check for the heigth
            # dato che abbiamo immagini minimo di 512 x 512 non ci preoccupiamo di fare un upsampling
            if heigth % tile_h == 0:
                num_tile_h = int(heigth/tile_h)
                offsets_h = [i*tile_h for i in range(num_tile_h)]
            elif heigth % tile_h != 0:
                # controlla prima il resto quant'è remaining = resto
                remaining_h = heigth % tile_h
                if remaining_h > self.thr_pixels:
                    num_tile_h = int(np.floor(heigth/tile_h)) + 1 
                else:
                    num_tile_h = int(np.floor(heigth/tile_h))
                offsets_h = [i*tile_h for i in range(num_tile_h-1)]
                offsets_h.append(heigth - tile_h)
            
            # check for the width
            # dato che abbiamo immagini minimo di 512 x 512 non ci preoccupiamo di fare un upsampling
            if width % tile_w == 0:
                num_tile_w = int(width/tile_w)
                offsets_w = [i*tile_w for i in range(num_tile_w)]
            elif width % tile_w != 0:
                # controlla prima il resto quant'è remaining = resto
                remaining_w = width % tile_w
                if remaining_w > self.thr_pixels:
                    num_tile_w = int(np.floor(width/tile_w)) + 1
                else:
                    num_tile_w = int(np.floor(width/tile_w))
                offsets_w = [i*tile_w for i in range(num_tile_w-1)]
                offsets_w.append(width - tile_w)

        except NotAnImage as nai:
            print(nai)
        finally:
            return offsets_w, offsets_h

    def get_tiles(self, ds):
        """
        Generator used to yield tiles one at a time. Employed in self.tiling()
        """
        # shape = (c, h, w) questa è l'immagine intera
        img_as_np = ds.read()
        ncols, nrows = ds.meta['width'], ds.meta['height']
        #offsets = itertools.product(range(0, ncols, self.tile_width), range(0, nrows, self.tile_height))
        offsets_w, offsets_h = self.offset_tiles(img_as_np)

        if offsets_w is None or offsets_h is None:
            raise NoneTypeEncountered(correct_type="List[float]")
        
        offsets = itertools.product(offsets_w, offsets_h)
        big_window = rio.windows.Window(col_off=0,
                                    row_off=0,
                                    width=ncols,
                                    height=nrows)

        for col_off, row_off in offsets:
            window = rio.windows.Window(col_off=col_off, row_off=row_off, width=self.tile_width, height=self.tile_height).intersection(big_window)
            transform = rio.windows.transform(window, ds.transform)
            yield window, transform

    def tiling(self) -> bool:
        """
        Actual function used to perform tiling of each activation in the dataset for its pre, post and mask.
        Eventually logs every absolute path in Log/master_dict.json
        """
        master_index = 0
        completed = False
        try:
            input_paths, activations = self.build_input_paths()

            if input_paths is None:
                raise NoneTypeEncountered(correct_type=Dict[str, str])
            if activations is None:
                raise NoneTypeEncountered(correct_type=List[str])
            if len(activations) == 0:
                raise EmptyListEncountered(list_name="activations", expected_content="activations' id")

            for idx in tqdm(range(len(activations))): # cycling through activations
                current_processing_folder=f"processed_{activations[idx]}"
                os.mkdir(f"{self.master_folder_path}/{current_processing_folder}") # creating dir for processed (tiled) activation
                
                if self.use_pre:
                    log_info = {f"{activations[idx]}" : {
                    "tile_info_pre": [],
                    "tile_info_post": [],
                    "tile_info_mask": []
                    }}
                else:
                    log_info = {f"{activations[idx]}" : {
                    "tile_info_post": [],
                    "tile_info_mask": []
                    }}

                if self.verbose==1:
                    print(f"Working with: {activations[idx]}")
                    print(f"Creating processing folder: processed_{activations[idx]}")

                for subitem_idx in range(len(self.input_paths_subitems)): #cycling through pre/post/mask
                    subitem = self.input_paths_subitems[subitem_idx]
                    if subitem is None:
                        raise NoneTypeEncountered(correct_type=str)
                    tile_info= list() # resetting tile info for each subitem
                    if os.path.isfile(input_paths[activations[idx]][subitem]): # if the subitem actually exists
                        with rio.open(input_paths[activations[idx]][subitem]) as inds:
                            meta = inds.meta.copy() # preparing img metadata
                            os.mkdir(f"{self.master_folder_path}/{current_processing_folder}/{subitem}") # creating dir for tiled subitem
                            output_path = f"{self.master_folder_path}/{current_processing_folder}/{subitem}"
                            output_filename = 'tile_{}_{}.tif'

                            for window, transform in self.get_tiles(inds): # retrieving tiles and log paths
                                master_index += 1
                                meta['transform'] = transform
                                meta['width'], meta['height'] = window.width, window.height
                                outpath = os.path.join(output_path,output_filename.format(int(window.col_off), int(window.row_off)))
                                with rio.open(outpath, 'w', **meta) as outds:
                                    outds.write(inds.read(window=window))
                                    # tile_info.append(inds.read(window=window))
                                    tile_info.append(outpath)
                    log_info[f"{activations[idx]}"][f"tile_info_{subitem}"].append(tile_info)
                self.master_dict_info['processing_info'].append(log_info)
            self.log_dict_info_to_file() # log to Log/master_dict.json
            completed = True
        except OSError as ose:
            print(ose)
        except NoneTypeEncountered as nte:
            print(nte)
        except EmptyListEncountered as ele:
            print(ele)
        finally:
            return completed